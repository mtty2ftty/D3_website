<!DOCTYPE html>
<html>
<style>
   body {
      font-family: 'Arial', sans-serif; /* General font for HTML */
   }
</style>

<meta charset="utf-8">
<head>
<style type="text/css">
.inline {
  background-color: #f7f7f7;
  border:solid 1px #B0B0B0;
}
.error {
	font-weight: bold;
	color: #FF0000;
}
.warning {
	font-weight: bold;
}
.message {
	font-style: italic;
}
.source, .output, .warning, .error, .message {
	padding: 0 1em;
  border:solid 1px #F7F7F7;
}
.source {
  background-color: #f5f5f5;
}
.left {
  text-align: left;
}
.right {
  text-align: right;
}
.center {
  text-align: center;
}
.hl.num {
  color: #AF0F91;
}
.hl.sng {
  color: #317ECC;
}
.hl.com {
  color: #AD95AF;
  font-style: italic;
}
.hl.opt {
  color: #000000;
}
.hl.def {
  color: #585858;
}
.hl.kwa {
  color: #295F94;
  font-weight: bold;
}
.hl.kwb {
  color: #B05A65;
}
.hl.kwc {
  color: #55aa55;
}
.hl.kwd {
  color: #BC5A65;
  font-weight: bold;
}
</style>
    <title>Interactive ONS radial chart</title>
</head>
<body>
    <h1>Interactive ONS radial chart</h1>
    <p>This visualization represents a hierachy. Each segment is sized in proportion to the number of responses that comprise it and are colour-coded by their score.</p>
    <p>Segments further down the hierarchy can be clicked to explore the data further.</p>
    <div id="chart"></div>

<!-- Load d3.js -->
<script src="https://d3js.org/d3.v6.js"></script>

<!-- Create a div where the graph will take place -->
<div id="my_dataviz"></div>

<script>
const width = 1000;
const height = 1000;
const radius = width / 7;
const radiusOuterScale = 0.1;
const threshVal = 5;

//const data = {
//  "name": "Company", "score": 52,
//  "children": [
//    {
//      "name": "HR", "score": 62,
//      "children": [
//        {
//          "name": "HR UK", "score": 62,
//          "children": [
//            {"name": "HR UK Men",  "score": 52,
//             "children": [
//              {"name": "HR UK Old Men", "value": 38, "score": 52},
//              {"name": "HR UK Young Men", "value": 30, "score": 71}
//            ]},
//            {"name": "HR UK Women", "value": 60, "score": 71}
//          ]
//        },
//        {
//          "name": "HR France", "score": 72,
//          "children": [
//            {"name": "HR France Men", "value": 43, "score": 83},
//            {"name": "HR France Women", "value": 65, "score": 59}
//          ]
//        },
//        {"name": "HR Germany", "value": 89, "score": 50}
//      ]
//    },
//    {
//      "name": "Finance", "score": 82,
//      "children": [
//        {"name": "Fin UK", "value": 68, "score": 97},
//        {"name": "Fin France", "value": 68, "score": 82,
//        "children": [
//          {"name": "Fin France Paris", "value": 100, "score": 97},
//          {"name": "Fin France Nice", "value": 20, "score": 82},
//          {"name": "Fin France Bordeaux", "value": 10, "score": 100}
//        ]},
//        {"name": "Fin Tuvalu", "value": 1, "score": 100},
//        {"name": "Fin Vanuatu", "value": 2, "score": 0}
//      ]
//    },
//    {"name": "Ops", "value": 190, "score": 52}
//  ]
//};

const createDynamicHierarchy = (csvData) => {
  const root = { name: 'root', children: [] };
  csvData.forEach(row => {
    let currentLevel = root;
    for (let i = 0; i <= 10; i++) { // assuming 10 possible levels
      const levelName = row[`Level${i}`];
      if (!levelName) break;
      let node = currentLevel.children.find(child => child.name === levelName);
      if (!node) {
        node = { name: levelName, children: [] };
        currentLevel.children.push(node);
      }
      if (i === Object.keys(row).length - 4) {  // If it's a leaf node
        node.value = +row.value;
        node.score1 = +row.score1;
        node.score2 = +row.score2;
      }
      currentLevel = node;
    }
  });
  return root.children[0];
};

// Example d3 loading with dynamic parsing
d3.csv('C:\\Users\\Matty.Mason\\OneDrive - Ipsos\\D3js\\dummyHierarchy.csv').then(data => {
  const hierarchy = createDynamicHierarchy(data);
  // Use `hierarchyData` in your existing D3.js code for visualization consistency
});



const colors = ['#ff9900', '#ffcc00', '#ffff00', '#99ff99', '#dddddd'];
const labels = ['Scores below 50', 'Scores 50-60', 'Scores 60-70', 'Scores above 70','Redacted'];

// Create the color scale 
const colorScale = d3.scaleThreshold()
  .domain([50, 60, 70, 100]) // Define score thresholds
  .range([
    //colors[4], // redacted
    colors[0], // Light Red (for scores below 60)
    colors[1], // Light Orange (for scores 50-60)
    colors[2], // Light Yellow (for scores 60-70)
    colors[3],  // Light Green (for scores above 70)
  ]);
  


//// Compute the layout.
//const hierarchy = d3.hierarchy(data)
//    .sum(d => d.value)
//    .sort((a, b) => b.value - a.value);
//    
const root = d3.partition()
    .size([2 * Math.PI, hierarchy.height + 1])
  (hierarchy);
  
root.each(d => d.current = d);

hierarchy.each(node => {
  node.data.color = colorScale(node.data.score); // Keep original color for leaf nodes
});

const maxDepth = d3.max(root.descendants(), d => d.depth);
const hiddenLevels = maxDepth - 2;
//const radiusIncrement = 50;



// Create the arc generator.
const arc = d3.arc()
    .startAngle(d => d.x0)
    .endAngle(d => d.x1)
    .padAngle(d => Math.min((d.x1 - d.x0) / 2, 0.005))
    .padRadius(radius * 1.5)
    .innerRadius(d => d.y0 <=3 ? d.y0 * radius : (3 + (d.y0-3)*radiusOuterScale)*radius)
    .outerRadius(d => d.y1 <=3 ? d.y1 * radius : (3 + (d.y1-3)*radiusOuterScale)*radius)

// Create the SVG container.
const svg = d3.select("body").append("svg")
.attr("width", width)
.attr("height", height)
.append("g")
.attr("transform", `translate(${width / 2},${height / 2})`)
.attr("viewBox", [-width / 2, -height / 2, width, width])
    .style("font", "10px sans-serif");;



// Example assuming root is your data node for the center
const centerCircle = svg.append('circle')
  .attr('r', radius) // Set your desired radius
  .attr('fill', colorScale(root.data.score)); // Use colorScale on root node's data attribute


// Append the arcs.
const path = svg.append("g")
  .selectAll("path")
  .data(root.descendants())
  .join("path")
  .attr('fill-opacity', d => Math.max(0,1 - (d.depth * 0.2 )))
  .attr("fill", d => { 
    if(d.data.value < 5) {
      return colors[4]; // Grey for values less than 5
    } else {
      return d.children ? d.data.color : colorScale(d.data.score); // Original color logic
    }
  }) 
  .attr("pointer-events", d => arcVisible(d.current) ? "auto" : "none")
  .attr("d", d => arc(d.current));

// Make them clickable if they have children.
path.filter(d => d.children)
    .style("cursor", "pointer")
    .on("click", clicked);

const format = d3.format(",d");
path.append("title")
    .text(d => `${d.ancestors().map(d => d.data.name).reverse().join("/")}\n${format(d.value)}`);

const centerText = svg.append('text')
  .attr('text-anchor', 'middle')
  .attr('dy', '0.35em')
  .style('fill', 'black')
  .text(`${data.name}: ${data.score}%`);

const label = svg.append("g")
    .attr("pointer-events", "none")
    .attr("text-anchor", "middle")
    .style("user-select", "none")
  .selectAll("text")
  .data(root.descendants())
  .join("text")
    .attr("dy", "0.35em")
    .attr("fill-opacity", d => +labelVisible(d.current))
    .attr("transform", d => labelTransform(d.current))
    .text(d => d.value > threshVal ? d.data.name +": " +d.data.score + "%" : d.data.name +": Redacted");

const parent = svg.append("circle")
    .datum(root)
    .attr("r", radius)
    .attr("fill", "none")
    .attr("pointer-events", "all")
    .on("click", clicked);
    
//
const currentLevelsText = svg.append('text')
.attr('id', 'currentLevels')
.attr('x', 0) // Position based on your design
.attr('y', -height / 2 + 20) // Adjust position as needed
.style('text-anchor', 'middle')
.text('Currently showing levels 1 to 3');

const legend = svg.append('g')
  .attr('class', 'legend')
  .attr('transform', `translate(${-width/2+20}, ${-height/2+20})`)
  .raise();

colors.forEach((color, i) => {
  
  legend.append('rect')
    .attr('x', 0)
    .attr('y', i * 20)
    .attr('width', 18)
    .attr('height', 18)
    .style('fill', color);

  legend.append('text')
    .attr('x', 24)
    .attr('y', i * 20 + 9)
    .attr('dy', '0.35em')
    .style('text-anchor', 'start')
    .text(labels[i]);
  });

// Handle zoom on click.
function clicked(event, p) {
  parent.datum(p.parent || root);
  updateCurrentLevelsText(p); 
  // background circles
  svg.selectAll('path.background-circle').remove();
  
  root.each(d => d.target = {
    x0: Math.max(0, Math.min(1, (d.x0 - p.x0) / (p.x1 - p.x0))) * 2 * Math.PI,
    x1: Math.max(0, Math.min(1, (d.x1 - p.x0) / (p.x1 - p.x0))) * 2 * Math.PI,
    y0: Math.max(0, d.y0 - p.depth),
    y1: Math.max(0, d.y1 - p.depth)
  });
  
  // Update the center circle text upon clicking a segment
  parent.transition().duration(750).attr('fill', p.data.color);
  
  centerText.raise();
  centerText.text(`${p.data.name}: ${p.data.score}%`); 
  
  const t = svg.transition().duration(750);

  // Transition the data on all arcs, even the ones that arenâ€™t visible,
  // so that if this transition is interrupted, entering arcs will start
  // the next transition from the desired position.
  path.transition(t)
      .tween("data", d => {
        const i = d3.interpolate(d.current, d.target);
        return t => d.current = i(t);
      })
    .filter(function(d) {
      return +this.getAttribute("fill-opacity") || arcVisible(d.target);
    })
    .attr("pointer-events", d => arcVisible(d.target) ? "auto" : "none") 
      .attrTween("d", d => () => arc(d.current));

  label.filter(function(d) {
      return +this.getAttribute("fill-opacity") || labelVisible(d.target);
    }).transition(t)
      .attr("fill-opacity", d => +labelVisible(d.target))
      .attrTween("transform", d => () => labelTransform(d.current));
}

function arcVisible(d) {
  return d.y1 <= 3 && d.y0 >= 1 && d.x1 > d.x0;
}

function labelVisible(d) {
  return d.y1 <= 3 && d.y0 >= 1 && (d.y1 - d.y0) * (d.x1 - d.x0) > 0.03;
}

function labelTransform(d) {
  const x = (d.x0 + d.x1) / 2 * 180 / Math.PI;
  const y = (d.y0 + d.y1) / 2 * radius;
  return `rotate(${x - 90}) translate(${y},0) rotate(${x < 180 ? 0 : 180})`;
}

function updateCurrentLevelsText(p) {
  const currentDepth = p.depth;
  const visibleMaxDepth = computeMaxDepth(p); // Calculate maximum depth dynamically
  const visibleLevels = Math.min(visibleMaxDepth, currentDepth + 2); 
  const textContent = currentDepth === visibleLevels ? 
      `Currently showing level ${currentDepth+1}` : 
      `Currently showing levels ${currentDepth+1} to ${visibleLevels+1}`;

  d3.select("#currentLevels").text(textContent);
}


function computeMaxDepth(node) {
  if (!node.children || node.children.length === 0) {
      return node.depth;
  }
  return Math.max(...node.children.map(computeMaxDepth));
}

</script>
</body>
</html>



