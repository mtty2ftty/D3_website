<!DOCTYPE html>
<html>
<style>
   body {
      font-family: 'Arial', sans-serif; /* General font for HTML */
   }
</style>

<meta charset="utf-8">
<head>
    <title>Interactive ONS radial chart</title>
</head>
<body>
    <h1>Interactive ONS radial chart</h1>
    <p>This visualization represents a hierachy. Each segment is sized in proportion to the number of responses that comprise it and are colour-coded by their score.</p>
    <p>Segments further down the hierarchy can be clicked to explore the data further.</p>
    <div id="chart"></div>

<!-- Load d3.js -->
<script src="https://d3js.org/d3.v6.js"></script>

<!-- Create a div where the graph will take place -->
<div id="my_dataviz"></div>

<script>
const width = 1000;
const height = 1000;
const radius = width / 7;
const radiusOuterScale = 0.1;
const threshVal = 5;

// Import the JSON data
var dataPath = 'https://raw.githubusercontent.com/mjm1169/D3_website/refs/heads/main/dummyHierarchy.json';
d3.json(dataPath).then(function(data) {
    const colors = ['#ff9900', '#ffcc00', '#ffff00', '#99ff99', '#dddddd'];
const labels = ['Scores below 50', 'Scores 50-60', 'Scores 60-70', 'Scores above 70','Redacted'];

// Create the color scale 
const colorScale = d3.scaleThreshold()
  .domain([50, 60, 70, 100]) // Define score thresholds
  .range([
    //colors[4], // redacted
    colors[0], // Light Red (for scores below 60)
    colors[1], // Light Orange (for scores 50-60)
    colors[2], // Light Yellow (for scores 60-70)
    colors[3],  // Light Green (for scores above 70)
  ]);
  


// Compute the layout.
const hierarchy = d3.hierarchy(data)
    .sum(d => d.value)
    .sort((a, b) => b.value - a.value);
    
const root = d3.partition()
    .size([2 * Math.PI, hierarchy.height + 1])
  (hierarchy);
root.each(d => d.current = d);

//hierarchy.each(node => {
//if (node.children) { // Only apply to parent nodes
//  node.data.color = colorScale(weightedAverage(node)); // Store color in node.data
//} else {
//  node.data.color = colorScale(node.data.score); // Keep original color for leaf nodes
//}
//
//});

hierarchy.each(node => {
  node.data.color = colorScale(node.data.score); // Keep original color for leaf nodes
});

const maxDepth = d3.max(root.descendants(), d => d.depth);
const hiddenLevels = maxDepth - 2;
//const radiusIncrement = 50;



// Create the arc generator.
const arc = d3.arc()
    .startAngle(d => d.x0)
    .endAngle(d => d.x1)
    .padAngle(d => Math.min((d.x1 - d.x0) / 2, 0.005))
    .padRadius(radius * 1.5)
    .innerRadius(d => d.y0 <=3 ? d.y0 * radius : (3 + (d.y0-3)*radiusOuterScale)*radius)
    .outerRadius(d => d.y1 <=3 ? d.y1 * radius : (3 + (d.y1-3)*radiusOuterScale)*radius)

// Create the SVG container.
const svg = d3.select("body").append("svg")
.attr("width", width)
.attr("height", height)
.append("g")
.attr("transform", `translate(${width / 2},${height / 2})`)
.attr("viewBox", [-width / 2, -height / 2, width, width])
    .style("font", "10px sans-serif");;

//// Create outer rings
//for (let i = 1; i <= hiddenLevels; i++) {
//svg.append('path')
//  .attr('class', 'background-circle') 
//  .attr('d', d3.arc().innerRadius(radius*3).outerRadius(radius*3+5*i).startAngle(0).endAngle(2 * Math.PI))
//  .style('fill', '#dddddd')
//  .style('fill-opacity', '0.5');
//}

// Example assuming root is your data node for the center
const centerCircle = svg.append('circle')
  .attr('r', radius) // Set your desired radius
  .attr('fill', colorScale(root.data.score)); // Use colorScale on root node's data attribute


// Append the arcs.
const path = svg.append("g")
  .selectAll("path")
  .data(root.descendants())
  .join("path")
  .attr('fill-opacity', d => Math.max(0,1 - (d.depth * 0.2 )))
  .attr("fill", d => { 
    if(d.data.value < 5) {
      return colors[4]; // Grey for values less than 5
    } else {
      return d.children ? d.data.color : colorScale(d.data.score); // Original color logic
    }
  }) 
  .attr("pointer-events", d => arcVisible(d.current) ? "auto" : "none")
  .attr("d", d => arc(d.current));

// Make them clickable if they have children.
path.filter(d => d.children)
    .style("cursor", "pointer")
    .on("click", clicked);

const format = d3.format(",d");
path.append("title")
    .text(d => `${d.ancestors().map(d => d.data.name).reverse().join("/")}\n${format(d.value)}`);

const centerText = svg.append('text')
  .attr('text-anchor', 'middle')
  .attr('dy', '0.35em')
  .style('fill', 'black')
  .text(`${data.name}: ${data.score}%`);

const label = svg.append("g")
    .attr("pointer-events", "none")
    .attr("text-anchor", "middle")
    .style("user-select", "none")
  .selectAll("text")
  .data(root.descendants())
  .join("text")
    .attr("dy", "0.35em")
    .attr("fill-opacity", d => +labelVisible(d.current))
    .attr("transform", d => labelTransform(d.current))
    .text(d => d.value > threshVal ? d.data.name +": " +d.data.score + "%" : d.data.name +": Redacted");

const parent = svg.append("circle")
    .datum(root)
    .attr("r", radius)
    .attr("fill", "none")
    .attr("pointer-events", "all")
    .on("click", clicked);
    
//
const currentLevelsText = svg.append('text')
.attr('id', 'currentLevels')
.attr('x', 0) // Position based on your design
.attr('y', -height / 2 + 20) // Adjust position as needed
.style('text-anchor', 'middle')
.text('Currently showing levels 1 to 3');

//test
//svg.append('text')
//.attr('x', 50)  // X-coordinate
//.attr('y', 50)  // Y-coordinate
//.text("hid: "  + hiddenLevels + " max: "+maxDepth)  // Variable text
//.style('font-size', '16px')  // Optional styling
//.style('fill', 'black');  // Optional text color

const legend = svg.append('g')
  .attr('class', 'legend')
  .attr('transform', `translate(${-width/2+20}, ${-height/2+20})`)
  .raise();

colors.forEach((color, i) => {
  
  legend.append('rect')
    .attr('x', 0)
    .attr('y', i * 20)
    .attr('width', 18)
    .attr('height', 18)
    .style('fill', color);

  legend.append('text')
    .attr('x', 24)
    .attr('y', i * 20 + 9)
    .attr('dy', '0.35em')
    .style('text-anchor', 'start')
    .text(labels[i]);
  });

// Handle zoom on click.
function clicked(event, p) {
  parent.datum(p.parent || root);
  updateCurrentLevelsText(p); 
  // background circles
  svg.selectAll('path.background-circle').remove();
  
  ////add new background circles
  //const newHiddenLevels = maxDepth - (p.depth + 2);
  //for (let i = 1; i <= newHiddenLevels; i++) {
  //  svg.append('path')
  //    .attr('class', 'background-circle')
  //    .attr('d', d3.arc().innerRadius(radius * 3).outerRadius(radius * 3 + 5 * i).startAngle(0).endAngle(2 * Math.PI))
 //     .style('fill', '#dddddd')
//      .style('fill-opacity', '0.5');
//};

  root.each(d => d.target = {
    x0: Math.max(0, Math.min(1, (d.x0 - p.x0) / (p.x1 - p.x0))) * 2 * Math.PI,
    x1: Math.max(0, Math.min(1, (d.x1 - p.x0) / (p.x1 - p.x0))) * 2 * Math.PI,
    y0: Math.max(0, d.y0 - p.depth),
    y1: Math.max(0, d.y1 - p.depth)
  });
  
  // Update the center circle text upon clicking a segment
  parent.transition().duration(750).attr('fill', p.data.color);
  
  centerText.raise();
  centerText.text(`${p.data.name}: ${p.data.score}%`); 
  
  const t = svg.transition().duration(750);

  // Transition the data on all arcs, even the ones that arenâ€™t visible,
  // so that if this transition is interrupted, entering arcs will start
  // the next transition from the desired position.
  path.transition(t)
      .tween("data", d => {
        const i = d3.interpolate(d.current, d.target);
        return t => d.current = i(t);
      })
    .filter(function(d) {
      return +this.getAttribute("fill-opacity") || arcVisible(d.target);
    })
    .attr("pointer-events", d => arcVisible(d.target) ? "auto" : "none") 
      .attrTween("d", d => () => arc(d.current));
      //.attr('fill-opacity', d => {
      //switch (d.depth - p.depth) {
      //  case 0:
      //    return 1; // Full opacity for center
      //  case 1:
      //    return 0.6; // Less opacity for first level
      //  case 2:
      //    return 0.2; // More faded for second level
      //  default:
      //    return 0; // Even more faded for deeper levels
      //}
    //})
      

  label.filter(function(d) {
      return +this.getAttribute("fill-opacity") || labelVisible(d.target);
    }).transition(t)
      .attr("fill-opacity", d => +labelVisible(d.target))
      .attrTween("transform", d => () => labelTransform(d.current));
}

function arcVisible(d) {
  return d.y1 <= 3 && d.y0 >= 1 && d.x1 > d.x0;
}

function labelVisible(d) {
  return d.y1 <= 3 && d.y0 >= 1 && (d.y1 - d.y0) * (d.x1 - d.x0) > 0.03;
}

function labelTransform(d) {
  const x = (d.x0 + d.x1) / 2 * 180 / Math.PI;
  const y = (d.y0 + d.y1) / 2 * radius;
  return `rotate(${x - 90}) translate(${y},0) rotate(${x < 180 ? 0 : 180})`;
}

function updateCurrentLevelsText(p) {
  const currentDepth = p.depth;
  const visibleMaxDepth = computeMaxDepth(p); // Calculate maximum depth dynamically
  const visibleLevels = Math.min(visibleMaxDepth, currentDepth + 2); 
  const textContent = currentDepth === visibleLevels ? 
      `Currently showing level ${currentDepth+1}` : 
      `Currently showing levels ${currentDepth+1} to ${visibleLevels+1}`;

  d3.select("#currentLevels").text(textContent);
}


function computeMaxDepth(node) {
  if (!node.children || node.children.length === 0) {
      return node.depth;
  }
  return Math.max(...node.children.map(computeMaxDepth));
}
}).catch(function(error){
    console.log('Error loading the JSON file: ', error);
});




</script>
</body>
</html>


